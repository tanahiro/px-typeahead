<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs.
-->
<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<!--

##### Usage

    <px-typeahead max-suggestions="10" local-candidates="{{your-array-of-input-strings}}" placeholder="your-placeholder">
    </px-typeahead>


@element px-typeahead
@blurb showing px-typeahead is a Predix UI component that show possible completion options for the search term entered
@homepage index.html
@demo index.html
-->
<link rel="import" href="css/px-typeahead-styles.html">

<dom-module id="px-typeahead">
  <template>
    <style include="px-typeahead-styles"></style>
    <template is="dom-if" if="{{prefetchUrl}}">
      <iron-ajax
      auto
      url="{{prefetchUrl}}"
      handle-as="json"
      last-response="{{_prefetchedCandidates}}">
      </iron-ajax>
    </template>

    <div class$="[[_calculateParentDivClass(inputFocused)]]" tabindex="0" id="mainContainer">
      <div style="flex:0 1 99%;"><input id="search" class="search u-pl--"
      on-keyup="_keyup" on-keydown="_keydown" placeholder="{{placeholder}}" value="{{inputValue}}" on-focus="_onfocus" on-blur="_onblur"></input>
      </div>
      <div class="fa-stack" style="flex:0 0 1%;"><i class="fa fa-search"></i></div>
    </div>
    <template is="dom-if" if="{{_isSuggestionsEmtpy(_suggestions)}}">
      <div class="container" >
        <ul class="layout__item" id="searchResults">
          <template is="dom-repeat" items="{{_suggestions}}">
             <li tabindex="-1" on-iron-select="_select" on-mouseover="_onhover"
             on-keyup="_keyup" class="u-p--">
             {{item}}
            </li>
          </template>
        </ul>
      </div>
    </template>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-typeahead',

    /**
         * Properties block, expose attribute values to the DOM via 'notify'
         *
         * @property properties
         * @type Object
         */
    properties: {
      inputFocused: {
        type: Boolean,
        value: false,
        notify: true
      },
      /**
       * The placeholder for the input element.
       */
      placeholder:{
        type:String,
        value:'Enter Your Search Query'
      },
      /**
       * The search candidates from local data model.
       */
      localCandidates:{
      type: Array,
      value: function() {
        return [];
      }},
      /**
       * Url for a prefectched list in json format for the list of suggestion candidates.
       * The response should be an array - for example: ["a","b"]
       */
      prefetchUrl:{
        type: String,
        value: ''
      },
      /**
      * The prefetched candidates retrieved by prefetchUrl
      */
      _prefetchedCandidates:{
        type: Array,
        value: function() {
          return [];
        }
      },
      /**
       * Internal variable holding all matched suggestions.
       */
      _suggestions:{
        type: Array,
        value: function() {
          return [];
        },
        notify: true
      },
      /**
       * Maximum number of suggestions
       */
      maxSuggestions:{
        type:Number,
        value:5,
        notify:true
      },
      /**
       * Remote url to perform a search using the value in the input. The input value will be passed in as url parameter. The placeholder should be %QUERY.
       */
      remoteUrl:{
        type: String,
        value: ''
      },
      /**
       * A boolean property to indicate if a search happens with a remote Url.
       * must be used together with remoteUrl.
       */
      remoteUrlSearching:{
        type:Boolean,
        value:false,
        notify:true
      },
      /**
       * The current value of the input.
       */
      inputValue:{
        type:String,
        notify:true
      },
      /**
       * //TODO - For Future Input object.
       */
      inputObject:{
        type:Object,
        notify:true
      }
    },
    behaviors: [Polymer.IronResizableBehavior],
    listeners: {'iron-resize': '_setSearchResultSize'},
    ready: function() {
      // `ready` is called after all elements have been configured, but
      // propagates bottom-up. This element's children are ready, but parents
      // are not.
      //
      // This is the point where you should make modifications to the DOM (when
      // necessary), or kick off any processes the element wants to perform.
      document.addEventListener("click", function(){
        var ptinputs = document.querySelectorAll('px-typeahead');

        for (var i = 0, len = ptinputs.length; i < len; i ++){
          ptinputs[i]._suggestions = [];
        }
      });
      window.addEventListener('iron-resize', function() {console.log('resize!');});
    },
    _setSearchResultSize: function() {
      if (this.$$('#searchResults')) {
        var mainContainerRect = this.$.mainContainer.getBoundingClientRect();
        this.$$('#searchResults').style.width = mainContainerRect.width + 2 + 'px'; //that 2 is for the outline
      }
    },
    _isSuggestionsEmtpy: function() {
      return this._suggestions.length;
    },
    _calculateParentDivClass: function() {
      var focus = (this.inputFocused) ? ' focus' :'';
      return 'flex parentdiv u-pr-' + focus;
    },

    /**
     * Callback for keydown event, checks on keys up or down, and disables them.
     *
     * @param {e} event
     */
    _keydown: function(e) {
      if (e.which === 40 || e.which === 38){
          e.preventDefault();
      }
    },
    /**
     * adding the outline on focus of input
     *
     */
    _onfocus: function(e) {
      this.set('inputFocused', true);
    },
    /**
     * removing the outline on blur out of input
     *
     */
    _onblur: function(e) {
      this.set('inputFocused', false);
    },
    /**
     * on mouse over for each li item
     *
     */
    _onhover: function(e) {
      var alreadySelected = Polymer.dom(this.root).querySelector('.item-selected');
      if (alreadySelected){
        alreadySelected.classList.remove('item-selected');
      }
      e.currentTarget.classList.add('item-selected');
    },
    /**
     * Fired whenever an item is selected.
     * @event px-typeahead-item-selected
     * @param {String} {The Selected Value}
     */
    /**
     * Callback on click event on list item
     *
     */
    _select: function(e) {
      var suggestionsMenu = Polymer.dom(this.root).querySelector('ul');
      if (suggestionsMenu){
        var selectedItem = e.currentTarget,
            text = e.currentTarget.textContent.trim();

        selectedItem.classList.add('item-selected');
        this.$search.focus();
        this.set('inputValue',text);
        this.set('_suggestions',[]);
        this.fire('px-typeahead-item-selected',this.inputValue);
        e.stopPropagation();
      }
    },
    _downArrowPress: function(e) {
      var alreadySelected,
          selectedItem,
          suggestionsMenu,
          children;
      alreadySelected = Polymer.dom(this.root).querySelector('.item-selected');

      if (alreadySelected) {
        alreadySelected.classList.remove('item-selected');
        selectedItem = alreadySelected.nextElementSibling;

        if(selectedItem) {
         selectedItem.classList.add('item-selected');
        } else {
         return;
        }
      } else {
        suggestionsMenu = Polymer.dom(this.root).querySelector('ul');

        if (suggestionsMenu){
          children = suggestionsMenu.getElementsByTagName('li');
          selectedItem = children[0];
          selectedItem.classList.add('item-selected');
        }
      }
    this.set('inputValue',selectedItem.textContent.trim());
    },
    _upArrowPress: function(e) {
      var alreadySelected,
          selectedItem,
          suggestionsMenu,
          children;
      alreadySelected = Polymer.dom(this.root).querySelector('.item-selected');
      if (alreadySelected){
        alreadySelected.classList.remove('item-selected');
        selectedItem = alreadySelected.previousElementSibling;
        if(selectedItem) {
          selectedItem.classList.add('item-selected');
        } else {
          return;
        }
      } else {
        suggestionsMenu = Polymer.dom(this.root).querySelector('ul');

        if (suggestionsMenu) {
          children = suggestionsMenu.getElementsByTagName('li');
          selectedItem = children[0];
          selectedItem.classList.add('item-selected');
        }
      }
      this.set('inputValue',selectedItem.textContent.trim());
    },
    _enterOrSpacePress: function(e) {
      var alreadySelected,
          selectedItem,
          suggestionsMenu,
          children;

      this.set('inputValue','');
      alreadySelected = Polymer.dom(this.root).querySelector('.item-selected');

      if (alreadySelected){
        selectedItem = alreadySelected;
        selectedItem.classList.remove('item-selected');
      }

      this.set('inputValue',selectedItem.textContent.trim());
      this.set('_suggestions',[]);
      this.fire('px-typeahead-item-confirmed',selectedItem);
      Polymer.dom(this.root).querySelector('input').focus();
    },
    /**
     * Callback for keyup event
     *
     * @param {e} event
     */
    _keyup: function(e) {
      var alreadySelected,
          selectedItem,
          suggestionsMenu,
          children;

      if (e.which === 40){ //down Arrow
        this._downArrowPress(e);
      } else if (e.which === 38){  //up arrow
        this._upArrowPress(e);
      } else if (e.which === 13 || e.which === 32){ //enter or space keys
         this._enterOrSpacePress(e);
      } else {
        var input = this.$.search;
        this._search(input.value.trim());
        input.focus();
      }
    },
    _getTestCandidate:function(item){
      if (this.isCandidatesJson){
        var toTest = [];
        for (var i = 0, len=this.searchableProps.length; i < len; i ++){
          if (item[this.searchableProps[i]] !== "undefined"){
            toTest.push(item[this.searchableProps[i]]);
          }
        }
        return toTest;
      } else{
        return [item];
      }
    },
    _localCandidatesSearch: function(term) {
      var patt =  new RegExp(term.toLowerCase()),
          matched = [],
          i,
          len,
          toTest,
          j,
          jlen,
          item;

      for (i = 0, len=this.localCandidates.length; i < len; i ++){
        if (matched.length === parseInt(this.maxSuggestions)){
          break;
        }
        toTest = this._getTestCandidate(this.localCandidates[i]);
        for (j = 0,jlen=toTest.length; j < jlen; j ++){
          item = toTest[j];

          if (patt.test(item.toLowerCase())){
            matched.push(this.localCandidates[i]);
            break;
          }
        }
      }
      return matched;
    },
    _prefetchedCandidatesSearch: function(term) {
      var patt =  new RegExp(term.toLowerCase()),
          matched = [],
          i,
          len,
          toTest,
          j,
          jlen,
          item;

      for (i = 0, len=this._prefetchedCandidates.length; i < len; i ++){
        if (matched.length === parseInt(this.maxSuggestions)){
          break;
        }
        toTest = this._getTestCandidate(this._prefetchedCandidates[i]);
        for (j = 0,jlen=toTest.length; j <jlen; j ++){
          item = toTest[j];
          if (patt.test(item.toLowerCase())){
            matched.push(this._prefetchedCandidates[i]);
            break;
          }
        }
      }
      return matched;
    },
    _remoteUrlSearch: function(term) {
      var matched = [];

      var pt_element = this;

      var ironAjaxEl = document.createElement('iron-ajax');
      var ptinput = pt_element;
      var url = pt_element.remoteUrl.replace("%QUERY", term);
      ironAjaxEl.handleAs = "json";
      ironAjaxEl.url = url;

      ironAjaxEl.addEventListener('response', function(evt) {
        if(evt.detail.response) {
          var resp = evt.detail.response,
              remoteMatched = JSON.parse(resp),
              cuttedMatched = remoteMatched.slice(0,parseInt(ptinput.maxSuggestions)),
              matched = matched.concat(cuttedMatched);

        ptinput._suggestions = matched;
        pt_element.set('remoteUrlSearching',false);
        pt_element.fire('px-typeahead-remote-searching-end',pt_element);
        } else {
          return;
        }

      });

      this.debounce('remoteUrlSearch', function(){
        ironAjaxEl.generateRequest();
        pt_element.fire('px-typeahead-remote-searching-start',pt_element);
        pt_element.set('remoteUrlSearching', true);
      },this.remoteUrlWaitMs);
      return matched;
    },
    _search:function(term){

      var matched = [];

      if (!term){
        this.set('_suggestions',[]);
        return;
      }
      if (this.localCandidates && this.localCandidates.length){
        matched = this._localCandidatesSearch(term);
      }

      if (this._prefetchedCandidates && this._prefetchedCandidates.length){
        matched = this._prefetchedCandidatesSearch(term);
      }
      if (this.remoteUrl){
        matched = this._remoteUrlSearch(term);
      }
      else{
        this.set('_suggestions',matched);
        //make sure the results are the same size as the input box.
        this.async(function() {
          this._setSearchResultSize();
        },5);
      }
    }
    /**
     * this event is fired when the searching has begun on a remote data source
     * @event px-typeahead-remote-searching-start
     */
     /**
      * this event is fired when the searching has ended on a remote data source
      * @event px-typeahead-remote-searching-end
      */
  });

</script>
